// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include<Eigen/Dense>

#include <iostream>
#include <limits>
#include <vector>
#include <algorithm>
#include <utility>

//! Print debugging info (comment to go silent)
// #define DEBUG

///////////////////////////////////
//// BEGIN OF NON-EXISTING CODE
// The code does not exist: after this line, until the next END, there are definitions allowing ode45 to work
// out-of-the box with fundamental types and Eigen::Vectors/Matrices at the same time (i.e. an uniform way
// to compute the norm).
// WARNING: Contains magic and template trickery using SFINAE
// DANGER: DO NOT look at this if you do not know what you are doing

//! \brief Returns  lpNorm<Eigen::Infinity> (the \f$ l^\infty \f$ norm of an Eigen::Vector)  if not fundamental type.
//! T must have a member method lpNorm (like an Eigen::Vector)
template <class T,
typename std::enable_if<!std::numeric_limits<T>::is_specialized, bool>::type = true >
inline typename T::Scalar _norm(const T & t) {
    return t.template lpNorm<Eigen::Infinity>();
}

//! \brief Returns the \f$ l^\infty \f$ norm of a scalar, which is the absolute value.
template <class T,
typename std::enable_if<std::numeric_limits<T>::is_specialized, bool>::type = false >
inline T _norm(const T & t) {
    return std::abs(t);
}
//// END OF NON-EXISTING CODE
///////////////////////////////////

///////////////////////////////////
//// BEGIN OF PUBLIC INTERFACE
//! \brief Class for 4-5 RK integration similar to MATLAB ode45 integrator.
//! Computes the solution of an ODE with an adaptive Runge Kutta method of order 4/5, for the IVP
//! \f$ y' = f(y), y(0) = y0 \f$, with error control using the difference between the RK4 and RK5 methods.
//! Class works as follows:
//! 
//! 1. Call constructor, example:
//! ode45<Eigen::VectorXd> O(f);
//! 
//! 2. (optional) Set options, for instance:
//! O.options.<option_you_want_to_change> = <value>;
//! 
//! 3. Solve phase, e.g.:
//! auto sol = O.solve(y0, T);
//! or
//! std::vector<std::pair<RhsType, double>> O.solve(y0, T);
//! in addition a norm can be passed as third argument
//! 
//! 4. (optional) Get statistics:
//! O.statistics.<stat_you_want_to_get>
//! 
//! 5. (optional) Print data (statistics and options):
//! O.print();
//! \tparam StateType type of the initial data \f$ y_0 \f$ and of the solution \f$ y(t) \f$. We require to be able to
//! do basic operations on StateSpace, like copy/copy construct, and that we have a vector space structure implemented
//! using operators +, *, +=, *=. Moreover we require a norm lpNorm method (compatible with Eigen) (fundamental
//! types use std::abs)
//! \tparam RhsType type of the r.h.s. function \f$ f \f$, providing StateType operator()(const StateType & y)
template <class StateType, class RhsType = std::function<StateType(const StateType &)> >
class ode45 {
public:
    //! \brief Initialize the class by providing a rhs, RhsType is automatically deduced by at construction time.
    //! Copies rhs of \f$ y'(t) = rhs((y(t)) \f$ internally.
    //! \param[in] f function for the computation of r.h.s. (e.g. a lambda function).
    ode45(const RhsType & rhs) : f(rhs) { /* EMPTY */ }
    
    //! \tparam NormFunc function type for norm function/or
    //! \param[in] y0 initial data \f$ y_0 = y(0) \f$.
    //! \param[in] T final time for the integration.
    //! \param[in] norm optional norm function if a custom normis need ed or _norm is not defined above
    //! \return vector of pairs \f$ (y(t), t) \f$ for the selected snapshot times
    template<class NormFunc = decltype(_norm<StateType>)>
    std::vector< std::pair<StateType, double> > solve(const StateType & y0, double T, const NormFunc & norm = _norm<StateType>);
    
    //! \brief Print statistics and options of this class instance.
    void print();
    
    //! \brief Configuration parameters (a.k.a. options)
    //! Setting values here configures the ode45 class to use the selected options
    //! Setup this before calling solve(), e.g. with "ode45<StateType> O(f); ode45.options.rtol = 10e-5;"
    struct Options {
        bool         save_init         = true;  //!< Set true if you want to save the initial data
        bool         fixed_stepsize    = false; //!< TODO: Set true if you want a fixed step size
        unsigned int max_iterations    = 5000;  //!< Set the maximum number of rejected iterations
        double       min_dt            = -1.;   //!< Set the minimum step size
        double       max_dt            = -1.;   //!< Set the maximum step size
        double       initial_dt        = -1.;   //!< Set an initial step size
        double       start_time        = 0;     //!< Set a starting time
        double       rtol              = 1e-6;  //!< Relative tolerance for the error.
        double       atol              = 1e-8;  //!< Absolute tolerance for the error.
        
        bool         do_statistics     = false; //!< Set to true prior to solve to save statistics
    } options;
    
    //! \brief Contains usage statistics
    //! This is filled (i.e. contains meaningful values) after a call of solve()
    struct Statistics {
        unsigned int cycles            = 0;     //!< Number of loops (sum of all accepted and rejected steps)
        unsigned int steps             = 0;     //!< Number of actual time steps performed (accepted step)
        unsigned int rejected_steps    = 0;     //!< Number of rejected steps per step
        unsigned int funcalls          = 0;     //!< Function calls
    } statistics;
    
    //// END OF PUBLIC INTERFACE
    ///////////////////////////////////
private:
    ///////////////////////////////////
    //// BEGIN PRIVATE PART OF ODE45 CLASS, LOOK AT YOU OWN RISK
    
    //! A copy of rhs stored during initialization
    RhsType  f;
    
    //! Current time
    double   t;

    // RK45 coefficients and data, cf. https://github.com/rngantner/
    ////////////////////////////////////////
    //// 20071016, reported by Luis Randez
    // The Runge-Kutta-Fehlberg 4(5) coefficients
    // Coefficients proved on 20060827
    // See p.91 in Ascher & Petzold
    ////////////////////////////////////////
    //! Power factor for error control
    static constexpr double         _pow = 1. / 5;
    // Number of stages
    static const unsigned int       _s   = 6;
    // Matrix A from the Butcher scheme
    static Eigen::MatrixXd          _mA;
    // Quadrature weight vectors, non autonomous ODEs c coefficients
    static Eigen::VectorXd          _vb4, _vb5, _vc;
};

// Matrix A from the Butcher scheme
template <class StateType, class RhsType>
Eigen::MatrixXd ode45<StateType, RhsType>::_mA = (
    Eigen::MatrixXd(ode45<StateType, RhsType>::_s, ode45<StateType, RhsType>::_s-1) <<  
        0,          0,           0,           0,            0,
        1./4.,      0,           0,           0,            0,
        3./32.,     9./32.,      0,           0,            0,
        1932./2197, -7200./2197, 7296./2197,  0,            0,
        439./216,   -8,          3680./513,   -845./4104,   0,
        -8./27.,    2,           -3544./2565, 1859./4104,   -11./40.
).finished();
    
//The 4th order b-coefficients for same matrix A
template <class StateType, class RhsType>
Eigen::VectorXd ode45<StateType, RhsType>::_vb4 = (
    Eigen::VectorXd(ode45<StateType, RhsType>::_s) <<
        25./216,    0,           1408./2565,  2197./4104,   -1./5,     0
).finished();
    
// The 5th order b-coefficients for same matrix A
template <class StateType, class RhsType>
Eigen::VectorXd ode45<StateType, RhsType>::_vb5 = (
    Eigen::VectorXd(ode45<StateType, RhsType>::_s) <<
        16./135,    0,           6656./12825, 28561./56430, -9./50,    2./55
).finished();

// Non autonomous ODEs c coefficients
template <class StateType, class RhsType>
Eigen::VectorXd ode45<StateType, RhsType>::_vc = 
    ode45<StateType, RhsType>::_mA.rowwise().sum();
    
// Order of the RK scheme
template <class StateType, class RhsType>
const unsigned int ode45<StateType, RhsType>::_s;

template <class StateType, class RhsType>
template <class NormFunc>
std::vector< std::pair<StateType, double> > ode45<StateType, RhsType>::solve(const StateType & y0, double T, const NormFunc & norm) {
    // TODO: non-autonomous ODE
    
    // Setup step size default values if not provided by user
    t = options.start_time;
    unsigned int default_nsteps = 100;
    unsigned int default_minsteps = 10;
    if(options.initial_dt == -1.) {
        options.initial_dt = (T - t) / default_nsteps;
    }
    if(options.max_dt == -1.) {
        options.max_dt = (T - t) / default_minsteps;
    }
    if(options.min_dt == -1.) {
        options.min_dt = (T - t) * std::numeric_limits<double>::epsilon();
    }
    
    // Solution container (returned)
    std::vector< std::pair<StateType, double> > snapshots;
    
    // Read options from odeconf
    double dt = options.initial_dt;
    assert( dt > 0 && "Invalid option, dt must be positive");
    // TODO: allow negative time direction
    
    // Push initial data
    if( options.save_init ) {
        snapshots.push_back( std::make_pair(y0, t) );
    }
    
    // Configuration if fixed timestepping was requested
    if( options.fixed_stepsize ) {
//         TODO: implement fixed timestepping
    }
    
    // Temporary containers
    StateType ytemp0 = y0;
    StateType ytemp1 = y0;
    StateType ytemp2 = y0;
    // Pointers forswapping of temporary containers
    StateType *yprev = &ytemp0;
    StateType *y4 = &ytemp1, *y5 = &ytemp2;

    // Increment matrix (reserve space)
    std::vector<StateType> mK;
    mK.resize(_s);
    
    // Usage statistics
    unsigned int iterations = 0; // Iterations for current step
    
    // Main loop, exit if dt too small or final time reached
    while (t < T && dt >= options.min_dt) {
        // Force hitting the endpoint of the time slot exactly
        if(t + dt > T) {
            dt = T - t;
        }
        // Compute the matrix increments using the coefficients provided in _mA, _vb, _vc
        mK.front() = f(*yprev);
        for(unsigned int j = 1; j < _s; ++j) {
            mK.at(j) = *yprev;
            for(unsigned int i = 0; i < j; ++i) {
                mK.at(j) += (dt * _mA(j,i)) * mK.at(i);
            }
            mK.at(j) = f( mK.at(j) );
        }
        
        
        if( iterations >= options.max_iterations ) {
            std::cerr << "";
            abort();
        }
        statistics.funcalls += _s;

        // Compute the 4th and the 5th order estimations
        *y4 = *yprev;
        *y5 = *yprev;
        for(unsigned int i = 0; i < _s; ++i) {
            *y4 += (dt * _vb4(i)) * mK.at(i);
            *y5 += (dt * _vb5(i)) * mK.at(i);
        }

        // TODO: abs control
        double tau = 2., delta = 1.;
        // Calculate the absolute local truncation error and the acceptable  error
        if( !options.fixed_stepsize) { // if (!fixed_stepsize)
            delta = norm(*y5 - *y4);
            tau = std::max(options.rtol * std::max(norm(*yprev), 1.), options.atol);
        }
        
        // Check if step is accepted, if so, advance
        if( delta <= tau ) {
            t += dt;
            snapshots.push_back( std::make_pair(*y5, t) );
            std::swap(y5, yprev);
            ++statistics.steps;
            statistics.rejected_steps += iterations;
            iterations = 0;
        }
        
        // Update the step size for the next integration step
        if( !options.fixed_stepsize) {
            if ( delta <= std::numeric_limits<double>::epsilon() ) {
                dt *= 2;
            } else {
#ifdef DEBUG
                std::cout << dt << " " << tau << " "
                          << delta << " " << 0.8 * std::pow(tau / delta, _pow) << std::endl;
#endif
                dt *= 0.8 * std::pow(tau / delta, _pow);
            }
            dt = std::min(options.max_dt, dt);
        } else {
            // TODO: fixed step size
        }
        
        ++iterations;
        ++statistics.cycles;
        
        // Check if maximum number of iterations have been exeded
        if( iterations >= options.max_iterations ) {
            std::cerr << "Error: Solving has not been successful. The iterative integration "
                         "loop exited at time t = " << t << " before endpoint at tend = "
                         << T << " was reached. This happened because the iterative "
                         "integration loop does not find a valid solution at this time "
                         "stamp. Try to reduce the value of \"initial_dt\" and/or \"max_dt\""
                         << std::endl;
            abort();
        }
        
    }
    
    // Check if there was a premature exit
    if( t < T ) {
        std::cerr << "Error: Solving has not been successful. The iterative integration loop "
                     "exited at time t = " << t << " before endpoint at tend = " << T
                     << " was reached. This may happen if the stepsize grows smaller than "
                     "defined in \"min_dt\". Try to reduce the value of \"initial_dt\" and/or \"max_dt\""
                     << std::endl;
        abort();
    }
    
    // Returns all snapshots collected
    // TODO: option to select which snapshot to save
    return snapshots;
}

template <class StateType, class RhsType>
void ode45<StateType, RhsType>::print(void) {
    std::cout << "---------------------------------" << std::endl;
    std::cout << "Informations for the class ode45." << std::endl;
    std::cout << "---------------------------------" << std::endl;
    
    std::cout << " + Data:" << std::endl;
    std::cout << "    - current time of simulation:         " << t                          << std::endl;
    std::cout << " + Options:" << std::endl;
    std::cout << "    - relative tolerance:                 " << options.rtol               << std::endl;
    std::cout << "    - absolute tolerance:                 " << options.atol               << std::endl;
    std::cout << "    - minimal stepsize:                   " << options.min_dt             << std::endl;
    std::cout << "    - maximal stepsize:                   " << options.max_dt             << std::endl;
    std::cout << "    - initial stepsize:                   " << options.initial_dt         << std::endl;
    std::cout << "    - max. allowed rejected steps:        " << options.max_iterations     << std::endl;
    std::cout << "    - starting time:                      " << options.start_time         << std::endl;
    std::cout << "    - save initial data y(0):             " << options.save_init          << std::endl;
    std::cout << "    - use fixed stepsize:                 " << options.fixed_stepsize     << std::endl;
    if( options.do_statistics ) {
    std::cout << " + Statistics:" << std::endl;
    std::cout << "    - number of steps:                    " << statistics.steps            << std::endl;
    std::cout << "    - number of rejected steps:           " << statistics.rejected_steps   << std::endl;
    std::cout << "    - number of (while-)loops:            " << statistics.cycles           << std::endl;
    std::cout << "    - function calls:                     " << statistics.funcalls         << std::endl;
    }
}

//// END PRIVATE PART OF ODE45 CLASS, LOOK AT YOU OWN RISK
///////////////////////////////////
